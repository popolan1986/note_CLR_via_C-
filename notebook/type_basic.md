## 所有类型都从System.Object派生
CLR要求所有对象都用new操作符创建。以下是new操作符所做的事情：
1. 计算类型及其所有基类型（一直到System.Object，虽然它没有定义自己的实例字段）中定义的所有实例字段需要的字节数。堆上每个对象都需要一些额外的成员，包括"类型对象指针"和“同步块索引”。CLR利用这些成员管理对象。额外成员的字节数计入对象大小。
2. 从托管堆中分配类型要求的字节数，从而分配对象的内存，分配的所有字节都设为零
3. 初始化对象的"类型对象指针"和“同步块索引”成员。
4. 调用类型的实例构造器，传递在new调用中指定的实参。多数编译器都在构造器中自动生成代码来调用基类构造器。

new执行后，返回指向新建对象的一个引用。

## 运行时的相互关系
TODO

## 基元类型
编译器直接支持的数据类型称为基元类型（primitive type）。

## 值类型与引用类型
引用类型的性能问题主要体现在

1. 内存必须从托管堆分配
2. 对象有额外成员，比如同步快索引和类型对象指针
3. 从托管堆分配对象时，可能强制执行一次GC

值类型有时可以提供更好的性能，但应该满足如下条件：

1. 类型具有基元类型的行为，字段尽量是不可变的
2. 类型不需要从其他类型继承
3. 不派生
4. 实例大小

## 值类型的装箱和拆箱
装箱时发生了什么？
1. 在托管堆中分配内存
2. 值类型的字段复制到新分配的堆内存
3. 返回对象地址，现在该地址是对象
拆箱：
首先获取已装箱对象中各个字段的地址，然后将字段包含的值从堆复制到基于栈的值类型中

## 对象相等性与同一性
Equals重写时候GetHashCode也应该重现，算法应该至少使用一个实例字段，理想情况下，算法使用的字段应该不可变